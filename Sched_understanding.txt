Summary:
select_task_rq() decides new tasks cpu;
load_balance does most of pulling tasks periodically and during idle times.
active_load_balance_cpu_stop also does load_balancing sometimes.

Trying to Wake up process:
---------------------------------

try_to_wake_up()
	-> select_task_rq()
		-> select_task_rq_fair()
/*
 * select_task_rq_fair: Select target runqueue for the waking task in domains
 * that have the 'sd_flag' flag set. In practice, this is SD_BALANCE_WAKE,
 * SD_BALANCE_FORK, or SD_BALANCE_EXEC.
 *
 * Balances load by selecting the idlest CPU in the idlest group, or under
 * certain conditions an idle sibling CPU if the domain has SD_WAKE_AFFINE set.
 *
 * Returns the target CPU number.
 *
 * preempt must be disabled.
 */
---
---
	want_affine = !wake_wide(p) && !wake_cap(p, cpu, prev_cpu)
                              && cpumask_test_cpu(cpu, &p->cpus_allowed);
	for_each_domain:
	if want_affine:
		new_cpu = wake_affine(tmp, p, cpu, prev_cpu, sync);
	else:
		new_cpu = select_idle_sibling(p, prev_cpu, new_cpu);

---
---

Load balancing:
----------------------------------
/*
 * run_rebalance_domains is triggered when needed from the scheduler tick.
 * Also triggered for nohz idle balancing (with nohz_balancing_kick set).
 */
open_softirq(SCHED_SOFTIRQ, run_rebalance_domains);

run_rebalance_domains()
	-> rebalance_domains()
		-> load_balance()
			-> find_busiest_group()
				-> update_sd_lb_stats()
					-> for each group:
						-> update_sg_lb_stats()
						-> update_sd_pick_busiest()
				-> calculate_imbalance()
			-> find_busiest_queue()
			-> cur_ld_moved = detach_tasks(&env)
				-> can_migrate_task()
				-> load = task_h_load(p)
				-> detach_task(p, env) only if {(load/2) < env->imbalance}
			-> attach_tasks(&env)
				-> attach_task(env->dst_rq, p)
		-> update next tick
---
rebalance_domains:
---
/*
 * It checks each scheduling domain to see if it is due to be balanced
 */
-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-

-----------------------------------------
===>>> My WOF-Sched idea leveraging EAS:-
--------------------------------
topology:
------
ToDO: set SD_WOF_BALANCE in sd at topology building

---------
for newly waking process: select_task_rq_fair

- Find best cpu to place sleeping/newly created tasks
	-> gothrough each sd from bottom-to-top. use existing loop and prefer SD_WAKE_AFFINE before this, and then put the below part
		-> if (sd->flags & WOF_BALANCE && !sd->overutilized):
			-> find_best_energy_efficient_cfs_rq() in span(sd)
				-> Find cap_util and max_cap of non-idle sg
				-> check newly task can be placed in any sg. should not be overutilized after placing task.
				-> change prev_cpu = cpumask_first(sg->cpumask)
				-> select_task_fair in MC/SMT sd of prev_cpu
				-> return new_cpu.
		-> else bail out of WOF-balance and let CFS_do it's work.
		-> Note: else if(sd->flags & SD_BALANCE_WAKE), add !WOF_BALANCE


-------

for load balancing part:
Note: NUMA sd may do balancing in this case. so set WOF_BALANCE in each sd except leaf one.

-> should_we_balance():
	-> if(sd->flags & WOF_BALANCE && !sd->overutilized): return 0;

-> active_load_balance_cpu_stop():
	-> set if !WOF_BALANCE
----------

For idle going cpu :

-------
Note: Take care of locks and synchronization
update_sd_lb_stats()
-> For each group update cpu_util, and find if overloaded or not and set sd->overutilized with 0/1?

--------------Algorithm2-----------------------

Waking task: Find busiest group where the task can fit and place it.

load_balance: Find busiest_group and and if not overutilized then pull task from find_least_busiest_group()->find_least_busiest_queue()
